#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<math.h>

#include <stdio.h>

void puan_duan_sushu(int i)
{
    int m = 0;
    int isPrime = 1; // 假设i是素数

    if (i == 2 || i % 2 != 0)
    {
        for (m = 2; m <= i / 2; m++)
        {
            if (i % m == 0) // 如果m是i的因子
            {
                isPrime = 0; // i不是素数
                break;
            }
        }

        if (isPrime) // 如果i是素数
        {
            printf("%d\n", i);
        }
    }
}

int main()
{
    int a = 0;
    scanf("%d", &a);

    for (int i = 2; i < a; i++)
    {
        puan_duan_sushu(i);
    }

    return 0;
}


//int main()
//{
//    int a = 1000;
//    int b = 100;
//    int ret = 0;
//    int d = 0;
//    int c = 0;
//
//    for (b = 100; b < a; b++)
//    {
//        ret = b / 100;
//        c = b % 10;
//        d = (b / 10) % 10;
//
//        if ((pow(ret, 3) + pow(d, 3) + pow(c, 3)) == b)
//        {
//            printf("%d\n", b);
//        }
//    }
//
//    return 0;
//}

//int main()
//{
//	double sn = 0, an = 0, n, i,t, a = 2.0, b = 1.0;
//	scanf("%lf", &n);
//	sn += a / b;
//	for (i= 1; i < n; i++)
//	{
//		t = a;
//		a = a + b;
//		b = t;
//		an = a / b;
//		sn += an;
//	}
//	printf("%0.2lf\n", sn);
//	return 0;
//}

//
//int main()
//{
//	double a = 0, n = 0,ret=0,sum=0,sn=0;
//	scanf("%lf%lf", &a, &n);
//	while (n)
//	{
//		ret = a + a / 2;
//		sum += ret;
//		sn = sum - a / 2;
//		a = a / 2;
//		n--;
//	}
//	printf("%0.2lf,%0.2lf\n", a,sn);
//
//	return 0;
//}



//公式即为   X[n+1]=(X[n]+a/X[n])/2
//a.确定迭代变量（本题可设 x[x + 1]为x、x1为x[n]）
//b.建立迭代关系式(本题为 X[n + 1] = (X[n] + a / X[n]) / 2)
//c.对迭代过程加以控制（本题为 while (fabs(x - x1) > 1E-5)）
//在提供的代码中，变量 `x` 被初始化为值 `1.0`。这样的初始化在迭代方法中很常见，特别是在涉及平方根或涉及倒数的计算时。
//
//这段代码似乎实现了用于找到给定数字 `a` 平方根的牛顿 - 拉弗森方法。在这种方法中，平方根的初始猜测通常设置为 `1.0`，并且该算法通过迭代改进这个猜测，直到连续近似值（`x` 和 `x1`）之间的差异足够小。
//
//将 `x` 初始化为 `1.0` 是一个合理的选择，因为它是一个简单的起点，而且牛顿 - 拉弗森方法往往相对迅速地收敛到实际平方根。请注意，初始值的选择可能会影响算法的收敛速度，但对于平方根计算，使用 `1.0` 作为初始猜测是一种常见的做法。
//这个表达式 \(X[n+1] = \frac{X[n] + a}{2X[n]}\) 是一个迭代公式，通常用于实现平方根的牛顿迭代法。

//在这个公式中：
//
//- \(X[n]\) 是迭代过程中的当前值。
//- \(X[n + 1]\) 是迭代过程中的下一个值。
//- \(a\) 是一个常数，代表你想计算平方根的数。
//
//这个迭代过程的目标是逐渐逼近 \(a\) 的平方根。通过反复应用这个迭代公式，每次迭代都用当前值 \(X[n]\) 来计算下一个值 \(X[n + 1]\)。这个过程会不断重复，直到 \(X[n + 1]\) 和 \(X[n]\) 之间的差异足够小，或者达到了所需的精度。
//
//牛顿迭代法是一种数值逼近的方法，用于找到方程 \(f(x) = 0\) 的根。在这个情况下，方程是 \(f(x) = x ^ 2 - a\)，其中 \(a\) 是你想求平方根的数。迭代的过程实际上是在不断寻找 \(f(x) = 0\) 的解，即 \(x ^ 2 - a = 0\) 的解，而这个解就是 \(a\) 的平方根。
//
//总体而言，这个迭代公式是用来逼近一个数的平方根的方法，是数值计算中常见的一种技术。
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//	double x = 1.0, x1=0.0;
//	while (fabs(x - x1) > 1e-5)
//	{
//		x1 = x;
//		x = (x1 + a / x1) / 2;
//	}
//	printf("%0.3lf\n", x);
//	return 0;
//}


